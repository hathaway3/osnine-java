<!DOCTYPE chapter [
<!ENTITY mdash    "&#8212;" >
]>
<chapter xmlns="http://docbook.org/ns/docbook">
  <!-- page-118.png -->
  <title>OS-9 Service Request Descriptions</title>
  <titleabbrev>Service Request Descriptions - Level I and Level II</titleabbrev>
  <para>System calls are used to communicate between the OS-9 operating
system and assembly-language-level programs. There are three general
categories:</para>
  <orderedlist>
    <listitem>
      <para>User mode function requests</para>
    </listitem>
    <listitem>
      <para>System mode function requests</para>
    </listitem>
    <listitem>
      <para>I/O requests</para>
    </listitem>
  </orderedlist>
  <para>System mode function requests are privileged and may be executed
only while OS-9 is in the system state (when it is processing another
service request, executing a file manager, device drivers, etc.).
They are included in this manual primarily for the benefit of those
programmers who will be writing device drivers and other system-level
applications.</para>
  <para>The system calls are performed by loading the MPU registers with
the appropriate parameters (if any), and executing a SWI2
instruction immediately followed by a constant byte which is the
request code. Parameters (if any) will be returned in the MPU
registers after OS-9 has processed the service request. A standard
convention for reporting errors is used in all system calls; if an
error occurred, the <quote>C bit</quote> of the condition code register will be
set and accumulator B will contain the appropriate error code. This
permits a BCS or BCC instruction immediately following the system
call to branch on error/no error.</para>
  <para>Here is an example system call for the <xref linkend="i.close"/> service request:</para>
  <programlisting>
LDA PATHNUM
SWI2
FCB $8B
BCS ERROR
</programlisting>
  <para>Using the assembler's <quote>OS9</quote> directive simplifies the call:</para>
  <programlisting>
LDA PATHNUM
OS9 I$Close
BCS ERROR
</programlisting>
  <para>The I/O service requests are simpler to use than in many other
operating systems because the calling program does not have to
allocate and set up <quote>file control blocks</quote>, <quote>sector
buffers</quote>, etc. Instead OS-9 will return a one byte path number
when a path to a file/device is opened or created; then this path
number may be used in subsequent I/O requests to identify the
file/device until the path is closed. OS-9 internally allocates and
maintains its
own data structures and users never have to deal
with them: in fact attempts to do so are memory violations.</para>
  <para>All system calls have a mnemonic name that starts with <quote>F$</quote>
for system functions, or <quote>I$</quote> for I/O related requests.
These are defined in the assembler-input equate file
called <filename>OS9Defs</filename>.</para>
  <para>In the service request descriptions which follow, registers not
explicitly specified as input or output parameters are not altered.
Strings passed as parameters are normally terminated by having bit
seven of the last character set, a space character, or an end of line
character.</para>
  <para>
NOTE: The system call descriptions that follow are explained using a
particular notation. When F.xxx appears in the SYSTEM CALLS section, it
means that a <literal>BSR</literal> or <literal>LBSR</literal> is made instead of a system call. The SYSTEM
CALLS section shows the other routines the service request calls. Any
notation followed by <quote>*</quote> means that no error checking is done on return
from the system call. The DATA section shows what direct page
information is accessed by the service request.
</para>
  <para>
Thus, if a system call returns an error code, the user can trace its
origin. Some system calls generate errors themselves; these are listed
as POSSIBLE ERRORS. If the returned error code does not match any of the
given possible errors, then it was probably returned by another system
call made by the main call.
</para>
  <para><xref linkend="e.unksvc"/> (Unknown Service Request) can be returned from any OS-9
system call to signal that the service request has not been installed.
</para>
  <sect1>
    <title>User Mode Service Requests</title>
    <titleabbrev>Service Request Descriptions - User Mode</titleabbrev>
    <sect2 xml:id="f.allbit" xreflabel="F$AllBit">
      <title>F$AllBit - Set bits in an allocation bit map</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$AllBit</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 13</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>
              <simplelist>
                <member>LI - OS9p1</member>
                <member>LII - OS9p2</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(D) = Base address of allocation bit map.</member>
                <member>(X) = Bit number of first bit to set.</member>
                <member>(Y) = Bit count (number of bits to set)</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Bits set in given allocation map.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: ALLBIT is used by OS-9 to maintain internal allocation
maps. System memory is allocated using the following technique:
</para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>F$SchBit is called to locate free area.</para>
        </listitem>
        <listitem>
          <para>F$AllBit is called to reserve or allocate the bits.</para>
        </listitem>
        <listitem>
          <para>F$DelBit is called to release the bits when they are no longer needed.</para>
        </listitem>
      </orderedlist>
      <para>
The ALLBIT service request sets bits in the allocation bit map with the
number of the bit to be set Specified by the X register. Each bit is
equivalent to a certain amount of system resource be it memory, disk
space, etc.
</para>
      <para>
Bit numbers range from 0..N-1, where N is the number of bits in the
allocation bit map.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
          <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
    </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
              <simplelist>
                <member>LI - None.</member>
                <member>LII - <simplelist type="inline"><member>F$LDABX*</member><member>F$STABX*</member></simplelist>
</member>
              </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>CAVEATS:</term>
          <listitem>
            <para>LI - Beware calling AllBit with Y = 0 (Bit count of zero!)</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
    <sect2 xml:id="f.chain" xreflabel="F$Chain">
      <title>F$Chain - Load and execute a new primary module.</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$Chain</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 05</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(A) = Language / type code.</member>
                <member>(B) = Optional data area size (256 byte pages).</member>
                <member>(X) = Address of module name or file name.</member>
                <member>(Y) = Parameter area size (256 byte pages).</member>
                <member>(U) = Beginning address of parameter area.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <simplelist>
              <member>LI - <xref linkend="e.nemod"/> - module not executable.</member>
            <member><xref linkend="e.delsp"/> - memory size of zero.</member>
            <member><xref linkend="e.iforkp"/> - not enough memory for stack and parameters.</member>
            <member>LII - <xref linkend="e.nemod"/></member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: CHAIN is used when it is necessary to execute an entirely new
program, but without the overhead of creating a new process. It is
functionally similar to a FORK followed by an EXIT, but with less
processing overhead.
</para>
      <para>
The CHAIN system call is similar to <xref linkend="f.fork"/>, but it does not create a new
process. It effectively <quote>resets</quote> the calling process' program and
data memory areas and begins execution of a new primary module. Open
paths are not closed or otherwise affected.
</para>
      <para>The sequence of operations taken by <xref linkend="f.chain"/> is as follows:
</para>
      <para>1. The process' old primary module is
<emphasis>unlinked</emphasis>.</para>
      <para>2. The system parses the name string of the new process'
<quote>primary module</quote> - the program that will initially be executed. Then
the system module directory is searched to see if a module with the
same name and type / language is already in memory. If so it is
linked to. If not, the name string is used as the pathlist of a file
which is to be loaded into memory. Then the first module in this file
is linked to (several modules may have been loaded from a single
file).</para>
      <para>3. The data memory area is reconfigured to the size specified in
the new primary module's header.</para>
      <para>
4. Intercepts and any pending signals are erased.
</para>
      <para>The diagram below shows how <xref linkend="f.chain"/> sets up the
data memory area and registers for the new module.</para>
      <informalfigure>
        <screen>
   +-----------------+  &lt;--  Y          (highest address)
   !                 !
   !   Parameter     !
   !     Area        !
   !                 !
   +-----------------+  &lt;-- X, SP
   !                 !
   !                 !
   !   Data Area     !
   !                 !
   !                 !
   +-----------------+
   !   Direct Page   !
   +-----------------+  &lt;-- U, DP       (lowest address)

   D = parameter area size
  PC = module entry point abs. address
  CC = F=0, I=0, others undefined
</screen>
      </informalfigure>
      <para>Y (top of memory pointer) and U (bottom of memory pointer) will
always have a values at 256-byte page boundaries. If the parent does
not specify a parameter area, Y, X, and SP will be the same, and D
will equal zero. The minimum overall data area size is one page (256
bytes).</para>
      <warning>
        <para>
The hardware stack pointer (SP) should be located
somewhere in the direct page before the <xref linkend="f.chain"/> service request is
executed to prevent a <quote>suicide attempt</quote> error or an actual suicide
(system crash). This will prevent a suicide from occurring in case
the new module requires a smaller data area than what is currently
being used. You should allow approximately 200 bytes of stack space
for execution of the <xref linkend="f.chain"/> service request and other system
<quote>overhead</quote>.</para>
      </warning>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member>D.Proc</member>
                        <member>D.Usrsvc</member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member>D.Proc</member>
                        <member>D.Systsk</member>
                        <member>D.Sysprc</member>
                        <member>D.PrcDBT</member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member>F$UnLink*</member>
                        <member>F$Link</member>
                        <member>F$Load</member>
                        <member>F$Mem</member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member>F.Allproc</member>
                        <member>F$UnLink*</member>
                        <member>F$SLink*</member>
                        <member>F$Load</member>
                        <member>F$LDDDXY*</member>
                        <member>F$Mem</member>
                        <member>F$AllTsk*</member>
                        <member>F$LDABX*</member>
                        <member>F$STABX*</member>
                        <member>F$Move*</member>
                        <member>F$DelTsk*</member>
                        <member>F$SrtMem*</member>
                        <member>F$Aproc*</member>
                        <member>F$NProc*</member>
                        <member>F$Exit*</member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>CAVEATS:</term>
          <listitem>
            <simplelist>
              <member>LI and LII - Beware of chaining to system object module.</member>
              <member>LII - Beware of memory size of zero in module header.</member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
For more information, please see the <xref linkend="f.fork"/> service request
description.</para>
    </sect2>
    <sect2>
      <title>F$CmpNam - Compare two names</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$CmpNam</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 11</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>
              <simplelist>
                <member>LI - OS9p1</member>
                <member>LII - OS9p2</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(B) = Length of first name.</member>
<member>(X) = Address of first name.</member>
<member>(Y) = Address of second name.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(CC) = C bit clear if the strings match.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>None. CC indicates only the match/nomatch condition.
B doesn't contain an error code.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>FUNCTION:</term>
          <listitem>
            <para>To be used in combination with parsename.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
Given the address and length of a string, and the address of a second
string, CMPNAM compares them and indicates whether they match.
</para>
      <para>
The second name must have the sign bit (bit 7) of the last character set.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>None.</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SysDAT</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - None.</member>
        <member>LII - None.</member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
The second string must be terminated with the high order bit set.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.crc" xreflabel="F$CRC">
      <title>F$CRC - Compute CRC</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$CRC</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 17</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(X) = Starting byte address.</member>
<member>(Y) = Byte count.</member>
<member>(U) = Address of 3 byte CRC accumulator.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>CRC accumulator is updated.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: To allow the system to easily generate/check CRC values of
modules.
</para>
      <para>
F$CRC calculates the CRC (cyclic redundancy count) for use by compilers,
assemblers, or other module generators. The CRC is calculated starting
at the source address over <quote>byte count</quote> bytes. It is not necessary to
cover an entire module in one call, since the CRC may be
"accumulated" over several calls. The CRC accumulator can be any three
byte memory location and must be initialized to $FFFFFF before the first
F$CRC call for any particular module.
</para>
      <para>
When checking an existing module CRC, the calculation should be performed
on the entire module (including the module CRC). The CRC accumulator
will contain the CRC constant bytes if .the module CRC is correct.
Checking an existing CRC can also be done similar to below for checking a
CRC match.
</para>
      <para>
If the CRC of a new module is to be generated, the CRC is accumulated
over the module (excluding CRC). The accumulated CRC is complemented
then stored in the correct position in the module.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>None.</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SysTsk</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>
      <simplelist>
        <member>LI - None.</member>
        <member>LII - None.</member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
CAVEATS: Be sure to initialize CRC accumulator only once for each module checked.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.delbit" xreflabel="F$DelBit">
      <title>F$DelBit - Deallocate in a bit map</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$DELBIT</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 14</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>
              <simplelist>
                <member>LI - OS9p1</member>
                <member>LII - OS9p2</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(D) = Bit number of first bit to clear.</member>
<member>(X) = Base address of an allocation bit map.</member>
<member>(Y) = Bit count (number of bits to clear).</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Bits cleared in allocation map.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: DELBIT is used by the system to maintain internal allocation maps. See also <xref linkend="f.allbit"/>.
</para>
      <para>
DELBIT is used to clear bits in the allocation bit map pointed to by X.
</para>
      <para>
Bit numbers range from 0..N-1, where N is the number of bits in the
allocation bit map.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>D.Proc</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>None.</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - None.</member>
        <member>LII - 
          <simplelist type="inline">
            <member>F$LDABX*</member>
            <member>F$STABX*</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>Beware of calling with Y = 0 (Bit count of zero).</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.exit" xreflabel="F$Exit">
      <title>F$Exit - Terminate the calling process.</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$EXIT</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 06</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <simplelist>
              <member>LI - OS9p2</member>
                <member>LII - OS9p2</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(B) = Status code to be returned to the parent process.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Process is terminated.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: The F$EXIT call kills the calling process and is the only
means by which a process can terminate itself. Its data memory area is
deallocated, and its primary module is UNLINKed. All open paths are
automatically closed.
</para>
      <para>
The death of the process can be detected by the parent executing a WAIT
call, which returns to the parent the status byte passed by the child in
its EXIT call. The status byte can be an OS-9 error code that the
terminating process wishes to pass back to its parent process (the <application>shell</application>
assumes this), or it can be used to pass a user-defined status value.
Processes to be called directly by the shell should only return an OS-9
error code or zero if no error occurred.
</para>
      <para>
The following information describes the order of operation of an F$EXIT
call.
</para>
      <para>
        <orderedlist numeration="arabic">
          <listitem>
            <para>Close all paths.</para>
          </listitem>
          <listitem>
            <para>Return memory to system.</para>
          </listitem>
          <listitem>
            <para>Unlink primary module.</para>
          </listitem>
          <listitem>
            <para>LII - Free task number.
LI - Clear all sibling links and their parent ID.
Free process descriptor of any dead child.</para>
          </listitem>
          <listitem>
            <para>LII - Clear all sibling links and their parent ID.
LI - If parent is dead, free the process descriptor.</para>
          </listitem>
          <listitem>
            <para>If parent is alive:
    A. Search wait queue of parent.</para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>If parent cannot be found, note the process death
in process state and leave the process in limbo
until parent notices the death.</para>
              </listitem>
              <listitem>
                <para>If parent found then move parent to active queue,
inform parent of death/status, remove child from
sibling list, and free process descriptor for the system.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PrcDBT</member>
            <member>D.WProcQ</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SysStk</member>
            <member>D.PrcDBT</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>I$Close*</member>
                <member>F$SrtMem*</member>
                <member>F$UnLink*</member>
                <member>F$Find64*</member>
                <member>F$Ret64*</member>
                <member>F$AProc*</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
                <member>I$Close*</member>
                <member>F$DelImg*</member>
                <member>F$UnLink*</member>
                <member>F$DelTsk*</member>
                <member>F.GetProc*</member>
                <member>F.RetProc*</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
Only the primary module is unlinked. Any module that is loaded
or linked to by the process should be unlinked before calling F$EXIT.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.fork" xreflabel="F$Fork">
      <title><phrase xml:id="lf.fork">F$Fork</phrase> - Create a new process</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$Fork</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 03</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>
              <simplelist>
                <member>LI - OS9p1</member>
                <member>LII - OS9p2</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(A) = Language / Type code.</member>
                <member>(B) = Optional data area size (pages).</member>
                <member>(X) = Address of module name or file name.</member>
                <member>(Y) = Parameter area size. (Number of bytes)</member>
                <member>(U) = Beginning address of the parameter area.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(X) = Updated past the name string.</member>
                <member>(A) = New process ID number.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <simplelist>
                <member>LI - <simplelist type="inline">
                            <member><xref linkend="e.prcful"/></member>
                            <member><xref linkend="e.nemod"/></member>
                            <member><xref linkend="e.delsp"/></member>
                            <member><xref linkend="e.iforkp"/></member>
                    </simplelist></member>
                <member>LII - <simplelist type="inline">
                            <member><xref linkend="e.nemod"/></member>
                            <member><xref linkend="e.prcful"/></member>
                    </simplelist></member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: FORK creates a new process which becomes a <quote>child</quote> of the
caller, and sets up the new process' memory, MPU registers, and standard
I/O paths.
</para>
      <para>
The system parses the name string of the new process' <quote>primary module</quote> &mdash;
the program that will initially be executed. Then the system module
directory is searched to see if the program is already in memory. If so,
the module is linked to and executed. If not, the name string is used
as the pathlist of the file which is to be loaded into memory. Then the
first module in this file is linked to and executed (several modules may
have been loaded from a single file).
</para>
      <para>
The primary module's module header is used to determine the process'
initial data area size. OS-9 then attempts to allocate RAM area equal
to the required data storage size or the passed parameter optional data
area size whichever is larger, (includes the parameter passing area,
which is copied from the parent process' data area). In LI the RAM area
must be contiguous, and in LII the RAM areas are pieced together. The
new process' registers are set up as shown in the diagram on the next
page. The execution offset given in the module header is used to set
the PC to the module's entry point.
</para>
      <para>When the <application>shell</application> processes a command line it passes a string in the
parameter area which is a copy of the parameter part (if any) of the
command line. It also inserts an end-of-line character at the end of
the parameter string to simplify string-oriented processing.
The X register will point to the beginning of the parameter string. If the
command line included the optional memory size specification (#n or #nK),
the <application>shell</application> will pass that size as the requested memory size when
executing the <xref linkend="f.fork"/>.</para>
      <para>If any of the above operations are unsuccessful, the <xref linkend="f.fork"/> is
aborted and the caller is returned an error.</para>
      <para>The diagram below
shows how <xref linkend="f.fork"/> sets up the data memory area and registers for a
newly-created process.</para>
      <informalfigure>
        <screen>
   +-----------------+  &lt;--  Y          (highest address)
   !                 !
   !   Parameter     !
   !     Area        !
   !                 !
   +-----------------+  &lt;-- X, SP
   !                 !
   !                 !
   !   Data Area     !
   !                 !
   !                 !
   +-----------------+
   !   Direct Page   !
   +-----------------+  &lt;-- U, DP       (lowest address)

   D = parameter area size
  PC = module entry point abs. address
  CC = F=0, I=0, others undefined
</screen>
      </informalfigure>
      <para>
Y (top of memory pointer) and U (bottom of memory pointer) will
always have a values at 256-byte page boundaries. If the parent does
not specify a parameter area, Y, X, and SP will be the same, and D
will equal zero. The minimum overall data area size is one page (256
bytes). <application>Shell</application> will always pass at least an end of line character in
the parameter area.
Thus, anything started from <application>shell</application> will always have a parameter area
ending with a carriage return.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
            <simplelist>
              <member>LI - <simplelist type="inline"><member>D.PrcDBT</member><member>D.Proc</member><member>D.UsrVC</member></simplelist>
</member>
              <member>LII - <simplelist type="inline"><member>D.Proc</member><member>D.SysTsk</member><member>D.PrcDBT</member></simplelist>
</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <simplelist>
              <member>LI - <simplelist type="inline"><member>F$ALL64</member><member>I$Dup*</member><member>F$Aproc*</member><member>F$EXIT</member><member>F$Link</member><member>F$Load</member><member>F$Mem</member></simplelist>.
                </member>
              <member>LII - <simplelist type="inline"><member>F.AllPrc</member><member>I$Dup*</member><member>F$SLink</member><member>F$Load</member><member>F$Mem</member><member>F$AllTsk*</member><member>F$Move*</member><member>F$DelTsk</member><member>F$AProc*</member><member>F$DelImg*</member><member>I$Close*</member><member>F$UnLink*</member><member>F$SRTMem</member><member>F$SRqMem</member></simplelist>.
</member>
            </simplelist>
          </listitem>
        </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>Both the child and parent process will execute
concurrently. If the parent executes a <xref linkend="f.wait"/> call
immediately after the fork, it will wait until the child dies before
it resumes execution. Caution should be exercised when recursively
calling a program that uses the <xref linkend="f.fork"/> service request since another
child may be created with each <quote>incarnation</quote> until the process table becomes full. Also, beware of
forking a process with a mem size of zero.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
    <sect2 xml:id="f.icpt" xreflabel="F$ICPT">
      <title>F$ICPT - Set up a signal intercept trap</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$ICPT</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 09</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <simplelist>
              <member>LI - OS9p2</member>
              <member>LII - OS9p2</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(X) = Address of the intercept routine.</member>
<member>(U) = Address of the intercept routine local storage.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Signals sent to the process will cause the intercept routine to
be called instead of the process being killed.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: ICPT tells OS-9 to set a signal intercept trap, where X
contains the address of the signal handler routine, and U contains the
base address of the routine's storage area.
</para>
      <para>
After a signal trap has been set, whenever the process receives a signal,
its intercept routine will be executed. A signal will abort any process
which has not used the F$ICPT service request to set a signal trap, and
its termination status (B register) will be the signal code. Many
interactive programs will set up an intercept routine to handle keyboard
abort and keyboard interrupt.
</para>
      <para>
The intercept routine is entered asynchronously because a signal may be
sent at any time (similar to an interrupt) and is passed the following:
</para>
      <para>
U = Address of intercept routine local storage.
B = Signal code.
</para>
      <para>
NOTE: The value of DP may not be the same as it was when the
F$ICPT call was made. Therefore, all ICPT routines should index
off the U register.
</para>
      <para>
Whenever a signal is received, OS-9 will pass the signal code and the
base address of its data area (which was defined by a F$ICPT service
request) to the signal intercept routine. The base address of the data
area is selected by the user and is typically a pointer to the process'
data area. The ICPT routine is entered when a process is beginning a new
time slice and it has a signal pending or is returning from a system call
or an IRQ.
</para>
      <para>
When the intercept conditions occur, a second stack frame is built below
the normal program stack area. The second stack frame has a PC for the
ICPT routine. Then an RTI will execute the ICPT routine. The interrupt
masks are set during the ICPT routine so it should be short and fast.
</para>
      <para>
After the ICPT routine has been completed, it should execute an RTI which
will begin normal process execution.
</para>
      <para>
The intercept routine is activated when a signal is received, then it
takes some action based upon the value of the signal code such as setting
a flag in the process' data area. After the signal has been processed,
the handler routine should terminate with an RTI instruction.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
    </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>None.</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.id" xreflabel="F$ID">
      <title>F$ID - Get process ID / user ID</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$ID</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 0C</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <simplelist>
              <member>LI - OS9p2</member>
              <member>LII - OS9p2</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Process ID.</member>
<member>(Y) = User ID.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: Returns the caller's process ID number, which is a byte value
in the range of 1 to 255, and the user ID which is a integer in the range
0 to 65535. The process ID is assigned by OS-9 and is unique to the
process. The user ID is defined in the system password file, and is used
by the file security system and a few other functions. Several processes
can have the same user ID.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>D.Proc</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>None.</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.link" xreflabel="F$Link">
      <title>F$Link - Link to memory module</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$LINK</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 00</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <simplelist>
              <member>LI - OS9p1</member>
              <member>LII - OS9p1</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Module type / language byte.</member>
<member>(X) = Address of the module name string.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Module type / language.</member>
              <member>(B) = Module attributes / revision level.</member>
              <member>(X) = Advanced past the module name.</member>
              <member>(Y) = Module entry point absolute address.</member>
              <member>(U) = Module header absolute address.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member><xref linkend="e.mnf"/></member>
                        <member><xref linkend="e.modbsy"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.mnf"/></member>
                        <member><xref linkend="e.modbsy"/></member>
                        <member><xref linkend="e.memful"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: LINK causes OS-9 to search the module directory for a module
having a name, language, and type as given in the parameters. If found,
the address of the module's header is returned in U, and the absolute
address of the module's execution entry point is returned in Y (as a
convenience: this and other information can.be obtained from the module
header). The module's <quote>link count</quote> is incremented whenever a LINK
references its name, thus keeping track of how many processes are using
the module. If the module requested has an attribute byte indicating it
is not sharable (meaning it is not reentrant), only one process may link
to it at a time.
</para>
      <para>
In Level II if a module is part of a group of modules and a link has
caused the entire group to be linked into local memory, the new link will
not cause the group to be linked in again. OS9 will discover that the
module is already available and the single module's link count will be
incremented.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>D.ModDir</member>
            <member>D.ModDir+2</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.ModDir</member>
            <member>D.ModEnd</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>F.PrsNam*</member>
            <member>F.CNAM*</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
              <member>F.PrsNam</member>
              <member>F.CNAM*</member>
              <member>F.LDDDXY*</member>
              <member>F.FreeHb*</member>
              <member>F.SetImg*</member>
              <member>F.DattoLog&lt;&lt;*</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.load" xreflabel="F$Load">
      <title>F$Load - Load module(s) from a file</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$LOAD</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 01</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - IOMAN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Language / type (0 = any language / type)</member>
<member>(X) = Address of pathlist (file name)</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) Language / type</member>
              <member>(B) = Attributes / revision level</member>
              <member>(X) = Advanced past pathlist</member>
              <member>(Y) = Primary module entry point address</member>
              <member>(U) = Address of module header</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member><xref linkend="e.bmid"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.memful"/></member>
                        <member><xref linkend="e.bmid"/></member>
                        <member><xref linkend="e.mnf"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: LOAD opens a file specified by the pathlist, reads one or more
memory modules from the file into memory, then closes the file. All
modules that are loaded are added to the system module directory, and the
first module read is LINKed. The parameters returned are the same as the
LINK call and apply only to the first module loaded.
</para>
      <para>
In order to be loaded, the file must have the <quote>execute</quote> permission and
contain a module or modules that have a proper module header and CRC.
The file will be loaded from the working execution directory unless a
complete pathlist is specified.

</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>None.</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SysTsk</member>
            <member>D.BlkMap</member>
            <member>D.ModDir</member>
            <member>D.ModEnd</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>I$Open</member>
                <member>I$Read</member>
                <member>F$SrqMem</member>
                <member>F$VModul</member>
                <member>F$SrtMem*</member>
                <member>I$Close*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$Allprc</member>
                <member>I$Open</member>
                <member>F$Alltsk</member>
                <member>F$Settsk</member>
                <member>I$Read</member>
                <member>F$Move*</member>
                <member>F$VModul</member>
                <member>I$Close*</member>
                <member>F$DelPrc*</member>
                <member>F$LDDDXY*</member>
                <member>F$ELink</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.mem" xreflabel="F$Mem">
      <title>F$Mem - Resize data memory area</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$MEM</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 07</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(D) = Desired new memory size in bytes.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(Y) = Address of upper bound of new memory area.</member>
<member>(D) = Actual size of new memory area in bytes.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI and LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.delsp"/></member>
                        <member><xref linkend="e.memful"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: MEM is used to contract or expand the process' data memory
area. The new size requested is rounded up to the next 256 byte page
boundary. Additional memory is allocated contiguously upward (towards
higher addresses), or deallocated downward from old highest address. If
D = O, the call is taken to be an information request and the current
upper bound and size will be returned.
</para>
      <para>
This request can never return all of a process' memory, or the page in
which its SP register points to. D must equal at least one to change memory size.
</para>
      <para>
In Level One systems, the request may return an error upon an expansion
request even though adequate free memory exits because the data area must
always be contiguous, and memory requests by other processes may fragment
memory into smaller, scattered blocks that are not adjacent to the
caller's present data area. Level Two systems do not have this
restriction because of the availability of hardware for memory
relocation, and because each process has its own address space.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PMBM</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
            <member>D.Proc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
          <simplelist type="inline">
                <member>F$SchBit</member>
                <member>F$AllBit*</member>
                <member>F$DelBit*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$AllImg</member>
                <member>F$DelImg</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.perr" xreflabel="F$PErr">
      <title>F$PErr - Print error message</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$PErr</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 0F</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - IOMAN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(B) = Error code.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Error Message.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: PERR is the system's error reporting utility. It writes an
error message to the standard error path. Most OS-9 systems will display:
<screen>
ERROR #&lt;decimal number&gt;
</screen>
by default. The error reporting routine is vectored and can be replaced
by a more elaborate reporting module. In Level 1 systems the reporting
module can be replaced. In Level 2 systems, a system routine may replace
the module, but the replacement will affect all users. Microware has not
implemented any PERR modification on Level 2 systems.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.Proc</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.Systsk</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>
      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>I$Writln*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$Move*</member>
                <member>I$Writln*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.prsnam" xreflabel="F$PrsNam">
      <title>F$PrsNam - Parse a path name</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$PrsNam</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 10</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Address of the pathlist.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(X) = Updated past the optional <quote>/</quote></member>
              <member>(Y) = Address of the last character of the name +1</member>
              <member>(A) = Trailing byte (Delimiter character)</member>
              <member>(B) = Count of characters found.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
                <member>(Y) = Address of first nondelimeter char in string</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bnam"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: PrsNam parses the input text string for a legal OS-9 name.
The name is terminated by any character that is not a legal component
character. PrsNam is useful for processing pathlist arguments passed to
new processes. Also, if X was at the end of a pathlist, a bad name error
will be returned and Y will be moved past any space or comma characters
so the next pathlist in a command can be parsed.
</para>
      <para>
NOTE: PrsNam processes only one name, so several calls may be needed to
process a pathlist that has more than one name. PrsNam will terminate a
name on recognizing a delimiter character or high order bit set. It will
skip one trailing comma or any number of trailing spaces.
</para>
      <para><emphasis>Before</emphasis> F$PrsNam CALL:</para>
      <screen>
+---+---+---+---+---+---+---+---+---+---+---+---+---
! / ! D ! 0 ! / ! F ! I ! L ! E !   !   !   !   !
+---+---+---+---+---+---+---+---+---+---+---+---+---
  ^
  X
</screen>
      <para><emphasis>After the</emphasis> F$PrsNam CALL:</para>
      <screen>
+---+---+---+---+---+---+---+---+---+---+---+---+---
! / ! D ! 0 ! / ! F ! I ! L ! E !   !   !   !   !
+---+---+---+---+---+---+---+---+---+---+---+---+---
      ^       ^
      X       Y       (B) = 2
</screen>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
            <para>LI - None</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <simplelist>
              <member>LI - None</member>
              <member>LII - <simplelist type="inline"><member>F.DATLog*</member><member>F.LDAXY*</member></simplelist>
</member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
    <sect2 xml:id="f.schbit" xreflabel="F$SchBit">
      <title>F$SchBit - Search bit map for a free area</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SchBit</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 12</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>
              <simplelist>
                <member>LI - OS9p1</member>
                <member>LII - OS9p2</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(D) = Beginning bit number</member>
              <member>(X) = Beginning address of bit map.</member>
              <member>(Y) = Bit count (free bit block size)</member>
              <member>(U) = End of bit map address.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(D) = Beginning bit number.</member>
                <member>(Y) = Bit count.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(CC) = C bit set.</member>
                <member>D and Y are returned, but Y will be less than specified.</member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SCHBIT searches the specified allocation bit map starting at
the beginning bit number (D) for a free block (cleared bits) of the required length.
</para>
      <para>
If no block of the specified size exists, it returns with the carry set,
beginning bit number and size of the largest block.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>None</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.Systsk</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - None</member>
        <member>LII - F$LDABX*</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>


    </sect2>
    <sect2 xml:id="f.send" xreflabel="F$Send">
      <title>F$Send - Send a signal to another process</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SEND</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 08</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Receiver's process ID number.</member>
<member>(B) = Signal code.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI and LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.iprcid"/></member>
                        <member><xref linkend="e.usigp"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SEND sends a signal to the process specified. The signal code
is a single byte value 0 - 255.
</para>
      <para>
If the destination process for the signal is sleeping or waiting, it will
be activated so that it may process the signal. The signal processing
routine (intercept) will be executed if a signal trap was set up (see
<xref linkend="f.icpt"/>), otherwise, the signal will abort the destination process, and
the signal code code becomes the exit status (see WAIT). An exception is
the WAKEUP signal, which activates a sleeping process but does not cause
the signal intercept routine to be examined and will not abort a process
that has not run an F$ICPT.
</para>
      <para>
Some of the signal codes have meanings defined by convention:
</para>
      <para>
        <simplelist>
<member>0 = System abort (unconditional)</member>
<member>1 = Wake up process</member>
<member>2 = Keyboard abort</member>
<member>3 = Keyboard interrupt</member>
<member>128 - 255 = User defined</member>
</simplelist>
      </para>
      <para>
If an, attempt is made to send a signal to a process that has an
unprocessed, previous signal pending, the current send request will be
cancelled and an error will be returned. An attempt can be made to try
resending the signal later. It is good practice to issue a sleep call
for a few ticks before a retry to avoid wasting CPU time.
</para>
      <para>
NOTE: A process may send the same signal to multiple processes of the
same ID by passing 0 as the receiver's process ID number. The superuser
(ID number 0) may send the same signal to all processes by the same
technique.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PrcDBT</member>
            <member>D.SProcQ</member>
            <member>D.WProcQ</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SProcQ</member>
            <member>D.WProcQ</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>F$AProc*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F.GProcP</member>
                <member>F$AProc*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
Notice that the super user is capable of mass murder, by
sending signal 0 to process 0.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.sleep" xreflabel="F$Sleep">
      <title>F$Sleep - Put calling process to sleep</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$Sleep</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 0A</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Sleep time in ticks (0 = indefinitely)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(X) = Decremented by the number of ticks that the process was asleep.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SLEEP deactivates the calling process for a specified time, or
indefinately if X = O. The process will be activated before the full
time interval if a signal is received, therefore. sleeping indefinately
is a good way to wait for a signal or interrupt without wasting CPU time.
</para>
      <para>
The duration of a <quote>tick</quote> is system dependent but is usually 100
milliseconds on Level I (50 ms with 6840) and 10 milliseconds on Level II.
</para>
      <para>Due to the fact that it is not known when the <xref linkend="f.sleep"/> request was
made during the current tick, <xref linkend="f.sleep"/> can not be used
to time more accurately than + or -1 tick.
A sleep of one tick is effectively a <quote>give up remaining
time slice</quote> request; the process is immediately inserted into
the active process queue and will resume execution when it reaches
the front of the queue. A sleep of two or more ticks causes the
process to be inserted into the active process queue after X - 1 ticks
occur and will resume execution when it reaches the front of the queue.</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SProcQ</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SProcQ</member>
            <member>D.Systsk</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$AProc*</member>
                <member>F$NProc*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$AProc*</member>
                <member>F$DelTsk*</member>
                <member>F$NProc*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2>
      <title>F$SPrior - Set process priority</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SPrior</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 0D</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Process ID number.</member>
              <member>(B) = Priority:
<literallayout>          0 = lowest
        255 = highest</literallayout></member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.iprcid"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SPrior changes the process priority to the new value given.
$FF is the highest possible priority, and $00 is the lowest. A process
can change another process' priority only if it has the same user ID.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.ProcDBT</member>
            <member>D.Proc</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - F$Find64</member>
        <member>LII - F.GProcP</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.ssvc" xreflabel="F$SSVC">
      <title>F$SSVC - Install function request</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SSVC</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 32</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(Y) = Address of service request initialization table.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <simplelist>
              <member>LI - <xref linkend="e.iswi"/></member>
              <member>LII - None.</member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SSVC is used to add a new function request to OS-9's user and
privileged system service request tables, or to replace an old one. The
Y register passes the address of a table which contains the function
codes and offsets to the corresponding service request handler routines.
This table has the following format:
</para>
      <screen>
OFFSET

          +----------------------+
 $00      !     Function Code    !  &lt;--- First entry
          +----------------------+
 $01      ! Offset From Byte 3   !
          +--                  --+
 $02      !  To Function Handler !
          +----------------------+
 $03      !     Function Code    !  &lt;--- Second entry
          +----------------------+
 $04      ! Offset From Byte 6   !
          +--                  --+
 $05      !  To Function Handler !
          +----------------------+
          !                      !   &lt;--- Third entry etc.
          !     MORE ENTRIES     !
          !                      !
          !                      !
          +----------------------+
          !         $80          !   &lt;--- End of table mark
          +----------------------+
</screen>
      <para>
NOTE: If the sign bit of the function code is set, only the system table
will be updated. Otherwise both the system and user tables will be
updated. Privileged system service requests may be called only while
executing a system routine.
</para>
      <para>
The service request routine should process the service request and return
from subroutine with an RTS instruction. They may alter any CPU
registers (except for SP). The U register will pass the address of the
register stack to the service request handler as shown in the following
diagram:
</para>
      <informalfigure>
        <screen>
                         OFFSET   OS9DEFS
                                  MNEMONIC
        +------+
U ---&gt;  !  CC  !            $0      R$CC
        +------+            $1      R$D
        !  A   !            $1      R$A
        +------+
        !  B   !            $2      R$B
        +------+
        !  DP  !            $3      R$DP
        +------+------+
        !      X      !     $4      R$X
        +-------------+
        !      Y      !     $6      R$Y
        +-------------+
        !      U      !     $8      R$U
        +-------------+
        !      PC     !     $A      R$PC
        +-------------+
</screen>
      </informalfigure>
      <para>
NOTE: The user service routine should set the CPU registers CC and B to
the appropriate values and return with RTS.- The service dispatcher will
then set R$CC and R$B in the user's register stack.
</para>
      <para>
LI - Function request codes are in the range 0 - $37
</para>
      <para>
LII - Function request codes are in the range 0 - $7E
</para>
      <para>
LI and LII function codes in the range $20 - $27 will not be used by
Microware and are free for user definition.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.SysDis</member>
          </simplelist>
        </member>
        <member>LII ONLY -
          <simplelist type="inline">
            <member>D.UsrDis</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
LII F$SSVC is only available to be called from system state by
system addressed object code.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.sswi" xreflabel="F$SSWI">
      <title>F$SSWI - Set SWI vector</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SSWI</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 0E</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = SWI type code.</member>
              <member>(X) = Address of user SWI service routine.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.iswi"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SSWI sets up the interrupt vectors for SWI, SWI2 and SWI3
instructions. Each process has its own local vectors. Each SETSWI call
sets up one type of vector according to the code number passed in A.
</para>
      <para>
        <simplelist>
          <member>1 = SWI</member>
          <member>2 = SWI2</member>
          <member>3 = SWI3</member>
        </simplelist>
      </para>
      <para>
When a process is created, all three vectors are initialized with the
address of the OS-9 service call processor.
</para>
      <variablelist role="factsheet">
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
Microware-supplied software uses SWI2 to call OS-9. If you
reset this vector these programs will not work. If you change all three
vectors, you will not be able to call OS-9 at all.
</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>DATA:</term>
          <listitem>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
    </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>
    <sect2 xml:id="f.stime" xreflabel="F$STime">
      <title>F$STime - Set system date and time</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$STIME</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 16</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Address of time packet (see below)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Time/date is set.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: STIME is used to set the current system date/time and start the
system real-time clock. STIME is accomplished by putting the date/time
packet in the system direct storage area, and then a link system call is
made to find the clock module. The clock initialization routine is
called if the link is successful, and it is the duty of the clock
initialization to:
</para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
Set up any hardware dependent functions (including moving new
date/time into hardware if needed).</para>
        </listitem>
        <listitem>
          <para>
Set up the F$Time system call via F$SSVC.</para>
        </listitem>
      </orderedlist>
      <para>
The date and time are passed in a time packet as follows:
</para>
<informaltable frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="1in"/>
<colspec colwidth="1.5in"/>
<thead>
<row rowsep="1">
  <entry>OFFSET</entry>
  <entry>VALUE</entry>
</row>
</thead>

<tbody>
<row>
  <entry colsep="1">0</entry> <entry>year</entry>
</row>
<row>
  <entry colsep="1">1</entry> <entry>month</entry>
</row>
<row>
  <entry colsep="1">2</entry> <entry>day</entry>
</row>
<row>
  <entry colsep="1">3</entry> <entry>hours</entry>
</row>
<row>
  <entry colsep="1">4</entry> <entry>minutes</entry>
</row>
<row>
  <entry colsep="1">5</entry> <entry>seconds</entry>
</row>
</tbody>
</tgroup>
</informaltable>

  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.Day</member>
            <member>D.Year</member>
            <member>D.Min</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Time</member>
            <member>D.Proc</member>
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$Link</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$Move*</member>
                <member>F$Link</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.time" xreflabel="F$Time">
      <title>F$Time - Get system date and time</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$TIME</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 15</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - Clock Module</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Address of place to store the time packet.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Time packet (see below).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: TIME returns the current system date and time in the form of a
six byte packet (in binary). The packet is copied to the address passed
in X. The packet looks like:
</para>

<informaltable frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="1in"/>
<colspec colwidth="1.5in"/>
<thead>
<row rowsep="1">
  <entry>OFFSET</entry>
  <entry>VALUE</entry>
</row>
</thead>

<tbody>
<row>
  <entry colsep="1">0</entry> <entry>year</entry>
</row>
<row>
  <entry colsep="1">1</entry> <entry>month</entry>
</row>
<row>
  <entry colsep="1">2</entry> <entry>day</entry>
</row>
<row>
  <entry colsep="1">3</entry> <entry>hours</entry>
</row>
<row>
  <entry colsep="1">4</entry> <entry>minutes</entry>
</row>
<row>
  <entry colsep="1">5</entry> <entry>seconds</entry>
</row>
</tbody>
</tgroup>
</informaltable>

  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>Hardware dependent</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
F$TIME is part of the clock module and will not exist if no
previous call to F$STime has been made.
</para>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="f.unlink" xreflabel="F$UnLink">
      <title>F$UnLink - Unlink a module</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$UNLINK</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 02</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>
              <simplelist>
                <member>LI - OS9p1</member>
                <member>LII - OS9p2</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(U) = Address of the module header.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: UNLINK tells OS-9 that the module is no longer needed by the
calling process. The module's link count is decremented, and the module
is destroyed and its memory deallocated when the link count equals zero.
The module will not be destroyed if in use by any other process(es)
because its link count will be non-zero. In Level Two systems, the
module is usually switched out of the process' address space. Also, any
module in the OS9 Boot file cannot be deleted.
</para>
      <para>
Device driver modules in use or certain system modules cannot be
unlinked. ROMed modules can be unlinked but cannot be deleted from the
module directory.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.ModDir</member>
            <member>D.BtLo</member>
            <member>D.PmBm</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>None.</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$IODel</member>
                <member>F$DelBit*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$LDDDXY*</member>
                <member>F$IODel</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
If a bad address is passed, UnLink will NOT find a module in the
module directory and will not return an error.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="f.wait" xreflabel="F$Wait">
      <title>F$Wait - Wait for child process to die</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$Wait</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 04</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Deceased child process' process ID.</member>
              <member>(B) = Child process' exit status code.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.nochld"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: The calling process is deactivated until a child process
terminates by executing an EXIT system call, or by receiving a signal.
The child's ID number and exit status is returned to the parent. If the
child died due to a signal, the exit status byte (B register) is the
signal code.
</para>
      <para>
If the caller has several children, the caller is activated when the
first one dies, so one WAIT system call is required to detect termination
of each child.
</para>
      <para>If a child died before the <xref linkend="f.wait"/> call, the caller is reactivated
almost immediately. <xref linkend="f.wait"/> will return an error if the caller has no
children.</para>
      <para>See the <xref linkend="f.exit"/> description for more related information.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
            <simplelist>
              <member>LI - <simplelist type="inline">
                 <member>D.Proc</member>
                 <member>D.PrcDBT</member>
                 <member>D.WProcQ</member>
              </simplelist>
              </member>
              <member>LII - <simplelist type="inline">
                 <member>D.Proc</member>
                 <member>D.WProcQ</member>
                 <member>D.PrcDBT</member>
                 <member>D.SysTsk</member>
              </simplelist>
              </member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <simplelist>
              <member>LI - F$Find64*</member>
              <member>LII -
                <simplelist type="inline">
                      <member>F.GProcP*</member>
                      <member>F$DelTSk</member>
                      <member>F$SrtMem*</member>
                      <member>F$NProc</member>
                </simplelist>
              </member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>CAVEATS:</term>
          <listitem>
            <para>
If the wait call returns with the carry bit set, then the wait
was not performed. If the wait returns with the carry clear, then the
wait functioned normally and any error that occurred in the child process
will be returned in (B).
</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>
  <sect1>
    <title>System Mode Service Requests</title>
    <sect2 xml:id="f.all64" xreflabel="F$All64">
      <title>F$All64 - Allocate a 64 byte memory block</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$ALL64</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 30</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Base address of page table (zero if the page table
has not yet been allocated).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Block number.</member>
<member>(X) = Base address of page table.</member>
<member>(Y) = Address of block.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI - <xref linkend="e.pthful"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: ALL64 is used to dynamically allocate 64 byte blocks of memory
by splitting whole pages (256 byte) into four sections. The first 64
bytes of the base page are used as a <quote>page table</quote>, which contains the MSB
of all pages in the memory structure. Passing a value of zero in the X
register will cause the F$ALL64 service request to allocate a new base
page and the first 64 byte memory block. Whenever a new page is needed,
an <xref linkend="f.srqmem"/> service request will automatically be executed. The first
byte of each block contains the block number; routines using this
service request should not alter it. Below is a diagram to show how 7
blocks might be allocated:
</para>
      <informalfigure>
        <screen>
                   ANY 256 BYTE            ANY 256 BYTE
                   MEMORY PAGE             MEMORY PAGE
BASE PAGE  ---&gt;   +-------------+         +-------------+
                  !             !         !X            !
                  !  PAGE TABLE !         !   BLOCK 4   !
                  !  (64 bytes) !         !  (64 bytes) !
                  +-------------+         +-------------+
                  !X            !         !X            !
                  !   BLOCK 1   !         !   BLOCK 5   !
                  !  (64 bytes) !         !  (64 bytes) !
                  +-------------+         +-------------+
                  !X            !         !X            !
                  !   BLOCK 2   !         !   BLOCK 6   !
                  !  (64 bytes) !         !  (64 bytes) !
                  +-------------+         +-------------+
                  !X            !         !X            !
                  !   BLOCK 3   !         !   BLOCK 7   !
                  !  (64 bytes) !         !  (64 bytes) !
                  +-------------+         +-------------+
</screen>
      </informalfigure>
      <para>
In LI, ALL64 is used by OS-9 to allocate path descriptors and process
descriptors. In LII, ALL64 is only used to allocate path descriptors
because process descriptors for LII are 512 bytes.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
            <para>LI and LII - None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <para>LI and LII - F$SrqMem</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.aproc" xreflabel="F$AProc">
      <title>F$AProc - Insert process in active process queue</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$APROC</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 2C</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Address of process descriptor.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: APROC inserts a process into the active process queue so that
it may be scheduled for execution.
</para>
      <para>
All processes already in the active process queue are aged, and the age
of the specified process is set to its priority. The process is then
inserted according to its relative age.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
LI and LII - <simplelist type="inline">
        <member>D.AProc</member>
    </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.find64" xreflabel="F$Find64">
      <title>F$Find64 - Find a 64 byte memory block</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$FIND64</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 2F</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p2</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Block number.</member>
                <member>(X) = Address of base page.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(Y) Address of block.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(CC) = C bit set.</member>
                <member>Indicates block not allocated or not in use.</member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: FIND64 will return the address of a 64 byte memory block as
described in the F$ALL64 service request. OS-9 uses this service request
to find prodess descriptors and path descriptors when-given their nUmber.
</para>
      <para>
Block numbers range from 1..N
</para>
      <para>
In LI, FIND64 is used to find process descriptors and path descriptors.
In LII, it is used only to find path descriptors because process
descriptors are 512 bytes in LII (see F$GProcP).
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.iodel" xreflabel="F$IODel">
      <title>F$IODel - Delete I/O device from system</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$IODEL</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 33</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Address of an I/O module. (see description)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.modbsy"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: The X register passes the address of an I/O module. The
address is used to search the device table, and if found the use count is
checked to see if it is zero. If it is not zero, an error condition-is
returned. IODEL is called by UNLINK when an I/O module is unlinked. I/O
modules are device drivers, device descriptors, and file Managers.
</para>
      <para>
LI - If a device is being unlinked for the final time ( there are no
other processes using the device), then IODEL performs the device
termination routine. For LII this has been moved to the DETACH system
call.
</para>
      <para>
LII - IODEL returns information to the UNLINK system call after
determining if a device is busy or not.
</para>
      <para>
This service request is used primarily by IOMAN and may be of limited or
no use for other applications.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Init</member>
            <member>D.DevTbl</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PrcDbt</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$SrtMem</member>
                <member>F$Send</member>
                <member>F$Find64</member>
                <member>Makes call to driver terminate routine.</member>
            </simplelist>
        </member>
        <member>LII - None.</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.ioqu" xreflabel="F$IOQu">
      <title>F$IOQu - Enter I/O queue</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$IOQU</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 2B</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(A) = Process Number.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: IOQU links the calling process into the I/O queue of the
specified process and performs an untimed sleep. It is assumed that
routines associated with the specified process will send a wakeup signal
to the calling process. IOQU is used primarily and extensively by IOMAN
and file managers.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PrcDBT</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>F$Send*</member>
                <member>F$Sleep*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$GProcP</member>
                <member>F$Sleep*</member>
                <member>F$Send*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.irq" xreflabel="F$IRQ">
      <title>F$IRQ - Add or remove device from IRQ table</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$IRQ</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 2A</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - IOMAN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(D) = Address of the device status register.</member>
              <member>(X) = Zero to remove device from table, or the address of a
packet as defined below to add a device to the IRQ polling table:
              <literallayout>
        [X] = flip byte
        [X+1] = mask byte
        [X+2] = priority
</literallayout></member>
              <member>(Y) = Device IRQ service routine address.</member>
              <member>(U) = Address of service routine's static storage area.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(CC) = C bit set.</member>
              <member>(B) = Appropriate error code.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.poll"/>. Error can be from full polling table or from bad mask byte (0).</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: IRQ is used to add a device to or remove a device from the IRQ
polling table. To remove a device from the table the input should be
(X)=0, (U)= Add: of service routine's static storage. This service
request is primarily used by device driver routines. See the text of this
manual for a complete discussion of the interrupt polling system.
</para>
      <para>
PACKET DEFINITIONS:
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>Flip Byte</term>
          <listitem>
            <para>This byte selects whether the bits in the device status
register are active when set or active when
cleared. A set bit(s) identifies the active low bit(s).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Mask Byte</term>
          <listitem>
            <para>This byte selects one or more bits within the device
status register that are interrupt request flag(s). A set bit
identifies an active bit(s)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Priority</term>
          <listitem>
            <para>
              <literallayout>The device priority number:
          0 = lowest
        255 = highest</literallayout>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>
LI and LII - <simplelist type="inline">
        <member>D.Init</member>
        <member>D.PolTbl</member>
    </simplelist>
    </para>
      </listitem>
    </varlistentry>
  </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.nproc" xreflabel="F$NProc">
      <title>F$NProc - Start next process</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$NProc</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 2D</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>Control does not return to caller.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system mode service request takes the next process out of
the Active Process Queue and initiates its execution. If there is no
process in the queue, OS-9 waits for an interrupt, and then checks the
active process queue again.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.AProcQ</member>
            <member>D.SWI2</member>
            <member>D.UsrIRQ</member>
            <member>D.SchIRQ</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysPrc</member>
            <member>D.Proc</member>
            <member>D.SysTsk</member>
            <member>D.AProcQ</member>
            <member>D.TSlice</member>
            <member>D.Slice</member>
            <member>D.UsrSvc</member>
            <member>D.XSWI2</member>
            <member>D.UsrIRQ</member>
            <member>D.XIRQ</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$EXIT*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$EXIT*</member>
                <member>F.AProc*</member>
                <member>F.AllTsk*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
The process calling NProc must already be in one of the three
process queues. If it is not, then it will become unknown to the system
even though the process descriptor still exists and will be printed out
by a Procs command.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.ret64" xreflabel="F$Ret64">
      <title>F$Ret64 - Deallocate a 64 byte memory block</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$Ret64</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 31</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Block number.</member>
<member>(X) = Address of the base page.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system mode service request deallocates a 64 byte block
of memory as described in the F$All64 service request.
</para>
      <para>
LI - F$Ret64 is used to free up or return a path descriptor or a process
descriptor
</para>
      <para>
LII - F$Ret64 is used to free only path descriptors.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
            <para>LI and LII - None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <para>F$SRTMem</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.srqmem" xreflabel="F$SRqMem">
      <title>F$SRqMem - System memory request</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SRqMem</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 28</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(D) = Byte count.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(U) = Beginning address of memory area.</member>
                <member>(D) = New Memory size</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.memful"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system mode service request allocates a block of memory
from the top of available RAM of the specified size. The size requested
is rounded to the next 256 byte page boundary.
</para>
      <para>
LII - Allocates memory for system address space only.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.FmBm</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysMem</member>
            <member>D.SysDAT</member>
            <member>D.BlkMap</member>
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - F$AllBit*</member>
        <member>LII - F.AllImg</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2>
      <title>F$SRTMem - Return System Memory</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$SRTMem</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 29</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(U) = Beginning address of memory to return.</member>
<member>(D) = Number of bytes to return.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para> LI and LII - <xref linkend="e.bpaddr"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system mode service request is used to deallocate a block
of contiguous 256 byte pages. The U register must point to an even page
boundary.
</para>
      <para>
LII - Deallocates memory for system address space only.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.FmBm</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysMem</member>
            <member>D.SysDAT</member>
            <member>D.BlkMap</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - F.DBit</member>
        <member>LII - None.</member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
    <sect2 xml:id="f.vmodul" xreflabel="F$VModul">
      <title>F$VModul - Verify module</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 F$VMODUL</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 2B</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - OS9p1</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>LI - (X) = Address of new module</member>
              <member>LII - (D) = DAT image pointer</member>
              <member>      (X) = New module block offset</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(U) = Address of module directory entry.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI and LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.kwnmod"/></member>
                        <member><xref linkend="e.dirful"/></member>
                        <member><xref linkend="e.bmid"/></member>
                        <member><xref linkend="e.bmcrc"/></member>
                    </simplelist>
                </member>
                <member>LII ONLY -
                    <simplelist type="inline">
                        <member><xref linkend="e.bmhp"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system mode service request checks the module header
parity and CRC bytes of an OS-9 module. If these values are valid, than
the module directory is searched for a module with the same name. If a
module with the same name and type exists, the one with the highest
revision level is retained in the module directory. Ties are broken in
favor of the established module.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>D.FmBm</member>
            <member>D.BtLo</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.ModDir</member>
            <member>D.ModEnd</member>
            <member>D.BlkMap</member>
            <member>D.ModDAT</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$DelBit*</member>
                <member>F.FModul</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F.LDDDXY*</member>
                <member>F.FModul</member>
                <member>F$GCMDir*</member>
                <member>F.LDAXY*</member>
                <member>F$Sleep</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

      <note>
        <para>This is a privileged system mode service request.</para>
      </note>
    </sect2>
  </sect1>
  <sect1>
    <title>I/O Service Requests</title>
    <titleabbrev>Service Request Descriptions - I/O Operations</titleabbrev>
    <sect2>
      <title>I$Attach - Attach a new device to the system.</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$ATTACH</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 80</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - IOMAN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Access mode.</member>
<member>(X) = Address of device name string.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(U) = Address of device table entry.</member>
<member>(X) = Updated past device name</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member><xref linkend="e.devovf"/></member>
                        <member><xref linkend="e.bmode"/></member>
                        <member><xref linkend="e.devbsy"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.devovf"/></member>
                        <member><xref linkend="e.bmode"/></member>
                        <member><xref linkend="e.memful"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: ATTACH is used to attach a new device to the system, or verify
that it is already attached. The device's name string is used to search
the system module directory to see if a device descriptor module with the
same name is in memory (this is the name the device will be known by).
The descriptor module will contain the name of the device's file manager,
device driver and other related information. If it is found and the
device is not already attached, OS-9 will link to its file manager and
device driver, and then place their address' in a new device table entry.
Any permanent storage needed by the device driver is allocated, and the
driver's initialization routine is called (which usually initializes the
hardware).
</para>
      <para>
If the device has already been attached, it will not be reinitialized.
</para>
      <para>
An ATTACH system call is not required to perform routine I/O. It does
NOT <quote>reserve</quote> the device in question - it just prepares it for subsequent
use by any process (see Note below). Most devices are automatically
installed, so it is used mostly when devices are dynamically installed or
to verify the existence of a device. IOMAN attaches all devices at open,
and detaches them at close.
</para>
      <para>
The access mode parameter specifies which subsequent read and/or write
operations will be permitted as follows:
</para>
      <para>
        <simplelist>
<member>0 = Use device capabilities.</member>
<member>1 = Read only.</member>
<member>2 = Write only.</member>
<member>3 = Both read and write.</member>
</simplelist>
      </para>
      <para>
Note: Attach and Detach are a like Link and Unlink for devices, and they
are usually used together. However, system performance can be improved
slightly if all devices are attached at startup. This increments each
device's use count and prevents the device from being reinitialized every
time it is opened. This also has the advantage of allocating the static
storage for devices all at once, which prevents fragmentation on Level
One systems.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Init</member>
            <member>D.Deval</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.SysDAT</member>
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$Link</member>
                <member>I$Detach*</member>
                <member>F$IOQU*</member>
                <member>F$SrqMem</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$SLink</member>
                <member>F$Link</member>
                <member>I$Detach*</member>
                <member>F$IOQu*</member>
                <member>F$SrqMem</member>
                <member>F$ID*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.chgdir" xreflabel="I$ChgDir">
      <title>I$ChgDir - Change working directory</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$ChgDir</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 86</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - IOMAN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Access mode.</member>
<member>(X) = Address of the pathlist.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(X) = Updated past pathlist</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI and LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnam"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: ChgDir changes a process' working directory to another
directory file specified by the pathlist. Depending on the access mode
given, the current execution, the current data directory may be changed,
or both. The file specified must be a directory file, and the caller
must have access permission for the specified mode.
</para>
      <para>
ACCESS MODES:
</para>

        <simplelist>
<member>1 = Read</member>
<member>2 = Write</member>
<member>3 = Update (read and write)</member>
<member>4 = Execute</member>
</simplelist>

      <para>
If the access mode is read, write, or update the current data directory
is changed. If the access mode is execute, the current execution
directory is changed.
</para>
      <para>
Note: The <application>shell</application> <quote>CHD</quote> directive uses UPDATE mode, which means you must
have both read and write permission to change directories from the <application>shell</application>.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.PrhDBT</member>
            <member>D.Proc</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$All64</member>
                <member>F$PrsNam</member>
                <member>I$Attach</member>
                <member>F$Ret64</member>
                <member>F$IOQu</member>
                <member>F$Send*</member>
                <member>F$Find64*</member>
                <member>I$Detach*</member>
            </simplelist>
            </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$All64</member>
                <member>F$LDABX*</member>
                <member>F$PrsNam</member>
                <member>I$Attach</member>
                <member>F$Ret64</member>
                <member>F$IOQU</member>
                <member>F$Send</member>
                <member>F$GProcP</member>
            </simplelist>
      </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.close" xreflabel="I$Close">
      <title>I$Close - Close a path to a file/device</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$CLOSE</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 8F</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(A) = Path number.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bpnum"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: Close terminates the I/O path specified by the path number.
The path number will no longer be valid for any OS-9 calls unless it
unless it becomes active again via I$Open, I$Create, or I$Dup. Devices that
are non-sharable become available to other requesting processes. All OS-9
internally managed buffers and descriptors are deallocated.
</para>
      <para>
Note: Because the OS9 F$Exit service request automatically closes all
open paths, it may not be necessary to close them individually with the
OS9 I$Close service request.
</para>
      <para>
Standard I/O paths are typically not closed except when it is desired to
change the files/devices they correspond to.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PthDBT</member>
          </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI and LII - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>I$Detach*</member>
                <member>F$Ret64*</member>
                <member>F$IOQu</member>
                <member>F$Send*</member>
            </simplelist>
            </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$GProcP*</member>
            </simplelist>
      </member>
    </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
I$Close does an implied I$Detach call. If it causes the device
use count to become zero, the device termination routine will be
executed. See <xref linkend="i.detach"/>.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.create" xreflabel="I$Create">
      <title>I$Create - Create a path to a new file</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$CREATE</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 83</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Access mode.</member>
<member>(B) = File attributes (access permission).</member>
<member>(X) = Address of the pathlist.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(X) = Updated past the pathlist (trailing blanks skipped)</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI and LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.pthful"/></member>
                        <member><xref linkend="e.bpnam"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: CREATE is used to create a new file on a multifile mass
storage device. On non-multifile devices, Create is synonymous with
Open. The pathlist is parsed, and the new file name is entered in the
specified (or default working) directory. The file is given the
attributes passed in the B register, which has individual bits defined
as follows:
</para>
      <para>
        <literallayout>
        bit 0 = read permit
        bit 1 = write permit
        bit 2 = execute permit
        bit 3 = public read permit
        bit 4 = public write permit
        bit 5 = public execute permit
        bit 6 = nonsharable file
</literallayout>
      </para>
      <para>
The access mode parameter passed in register A must have the write bit
set if any data is to be written to the file. This only affects the file
until it is closed; it can be reopened later in any access mode allowed
by the fil attributes (see OPEN). These access codes are defined as
given below:
</para>
      <para>
        <literallayout>
        2 = Write only.
        3 = Update (read and write).
</literallayout>
      </para>
      <para>
NOTE: If the execute bit (bit 2) is set, directory searching will begin
with the working execution directory instead of the working data
directory.
</para>
      <para>
The path number returned by OS-9 is used to identify the file in
subsequent I/O service requests until the file is closed.
</para>
      <para>
Data storage is allocated for the file automatically by WRITE or
explicitly by the PUTSTAT call.
</para>
      <para>
An error will occur if the pathlist specifies a file name that already
exists in. Create cannot be used to make directory files (see <xref linkend="i.makdir"/>).
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PthDBT</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$All64</member>
                <member>F$PrsNam</member>
                <member>I$Attach</member>
                <member>F$Ret64*</member>
                <member>F$IOQu*</member>
                <member>F$Send*</member>
                <member>F$Find64*</member>
            </simplelist>
            </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$All64</member>
                <member>F$LDABX*</member>
                <member>F$PrsNam</member>
                <member>I$Attach</member>
                <member>F$Ret64</member>
                <member>F$IOQu*</member>
                <member>F$Send*</member>
                <member>F$GProcp*</member>
            </simplelist>
      </member>
    </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
Create causes an implicit I$Attach call. If the device has not
previously been attached the device's initialization routine will be
called.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.delete" xreflabel="I$Delete">
      <title>I$Delete - Delete a file</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$DELETE</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 87</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(X) = Address of pathlist.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(X) = Updated past pathlist (trailing spaces skipped).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bpnam"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This service request deletes the file specified by the
pathlist. The caller must have non-sharable write access to the file or
an error will result (i.e. The file may not be open by any process).
Attempts to delete non-multifile devices will result in an error.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.PthDBT</member>
            <member>D.Proc</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>I$Detach*</member>
                <member>F$Ret64*</member>
                <member>F$All64</member>
                <member>F$PrsNam</member>
                <member>I$Attach</member>
                <member>F$IOQu</member>
                <member>F$Find64</member>
                <member>F$Send*</member>
            </simplelist>
            </member>
        <member>LII -
            <simplelist type="inline">
                <member>I$Detach*</member>
                <member>F$Ret64*</member>
                <member>F$All64</member>
                <member>F$LDABX*</member>
                <member>F$PrsNam</member>
                <member>I$Attach</member>
                <member>F$GProcP</member>
                <member>F$IOQu*</member>
                <member>F$Send*</member>
            </simplelist>
      </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.deletx" xreflabel="I$DeletX">
      <title>I$DeletX - Delete a file</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$DeletX</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 90</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(X) = Address of pathlist</member>
<member>(A) = Access mode</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(X) Updated past pathlist (trailing spaces skipped)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This service request deletes the file specified in the
pathlist. I$DeletX is identical to I$Delete except that it accepts a
mode byte, which allows the caller to specify the execution directory.
Not being able to specify a mode byte was an oversight in earlier
versions of OS-9. I$DeletX is the preferred system call to delete files.
</para>
      <para>
The caller must have non-sharable write access to the file or an error
will result. Attempts to delete devices will result in error.
</para>
      <para>
The access mode is used to specify the current working directory or the
current execution directory (but not both) in the absence of a full
pathlist. If the access mode is read, write, or update, the current data
directory is assumed. If the access mode is execute, the current
execution directory is assumed. Note that if a full pathlist is given (a
pathlist beginning with '/'), the access mode is ignored.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PthDBT</member>
          </simplelist>
        </member>
        <member>LII ONLY -
          <simplelist type="inline">
            <member>D.SysPrc</member>
          </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI and LII - 
            <simplelist type="inline">
                <member>F$All64</member>
                <member>F$PrsNam*</member>
                <member>I$Attach</member>
                <member>F$Ret64</member>
                <member>F$IOQu*</member>
                <member>File Mgr</member>
                <member>F$Send*</member>
                <member>F$Find64*</member>
                <member>I$Detach</member>
            </simplelist>
            </member>
        <member>LII ONLY -
            <simplelist type="inline">
                <member>F$LDABX*</member>
                <member>F$GProcP*</member>
            </simplelist>
      </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.detach" xreflabel="I$Detach">
      <title>I$Detach - Remove a device from the system</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$DETACH</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 81</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(U) = Address of the device table entry.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: LII - Removes a device from the system device table if not in
use by any other process. The device driver's termination routine is
called, then any permanent storage assigned to the driver is deallocated.
The device driver and file manager modules associated with the device are
unlinked (and may be destroyed if not in use by another process.
</para>
      <para>
LI - Performs unlink of all three I/O modules associated with the device
(driver, descriptor, file manager). Unlink then calls IODel to complete
the device termination.
</para>
      <para>
The I$DETACH service request must be used to un-attach devices that were
attached with the I$ATTACH service request. Both of these are used
mainly by IOMAN and are of limited (or no use) to the typical user.
SCF also uses ATTACH/DETACH to setup its second (echo) device.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <simplelist>
        <member>LI -
          <simplelist type="inline">
            <member>None.</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.Init</member>
            <member>D.Deval</member>
            <member>D.Proc</member>
            <member>D.SysPrc</member>
            <member>D.SysDAT</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>
      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$UnLink*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$RtMem*</member>
                <member>F$Send*</member>
                <member>F$GProcP*</member>
                <member>F$Unlink*</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.dup" xreflabel="I$Dup">
      <title>I$Dup - Duplicate a path</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$DUP</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 82</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI-and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>(A) = Path number of path to duplicate.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(A) = New path number.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.pthful"/>, <xref linkend="e.bpnum"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: Given the number of an existing path, DUP returns a synonymous
path number for the same file or device. <application>Shell</application> uses this service
request when it redirects I/O.
Service requests using either the old or new path numbers operate on the same file or device.
</para>
      <para>
NOTE: This only increments the <quote>use count</quote> of a path descriptor and
returns the synonymous path number. The path descriptor is NOT copied.
It is usually not a good idea for more than process to be doing I/O on the same path concurrently.
On RBF files, unpredictable results may be produced.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
        <member>D.PthDBT</member>
    </simplelist>
    </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>
      <para>LI and LII - F$Find64</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
The DUP will always use the lowest available path number.
For example, if the user does I$Close on path #0, then does I$Dup on path #4,
then path #0 will be returned as the new path number.
In this way, the standard I/O paths may be manipulated to contain any desired paths.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.getstt" xreflabel="I$GetStt">
      <title>I$GetStt - Get file/device status</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$GetStt</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 8D</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(B) Function code.</member>
<member>(Other registers depend upon status code)</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(depends upon function code)</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bpnum"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>FUNCTION: This system is a <quote>wild card</quote> call used to handle individual
device parameters that:</para>
      <orderedlist numeration="loweralpha">
        <listitem>
          <para>are not uniform on all devices</para>
        </listitem>
        <listitem>
          <para>are highly hardware dependent</para>
        </listitem>
        <listitem>
          <para>need to be user-changeable</para>
        </listitem>
      </orderedlist>
      <para>The exact operation of this call depends on the device driver and
file manager associated with the path.
A typical use is to determine a terminal's parameters for backspace character, delete
character, echo on/off, null padding, paging, etc.
It is commonly used in conjunction with the <xref linkend="i.setstt"/>
service request which is
used to set the device operating parameters. Below are presently
defined function codes for <xref linkend="i.getstt"/>:</para>
      <informaltable frame="none" rowsep="0" colsep="0">
        <tgroup cols="3">
          <colspec colwidth="1.2in"/>
          <colspec colwidth="1in"/>
          <colspec colwidth="3.5in"/>
          <thead>
            <row rowsep="1">
              <entry>MNEMONIC</entry>
              <entry>CODE</entry>
              <entry>FUNCTION</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>SS.Opt</entry>
              <entry>$0</entry>
              <entry>Read the 32 byte option section of the path descriptor. (IOMAN - LI, LII)</entry>
            </row>
            <row>
              <entry>SS.Ready</entry>
              <entry>$1</entry>
              <entry>Test for data ready. (RBF, Acia - LI, LII)</entry>
            </row>
            <row>
              <entry>SS.Size</entry>
              <entry>$2</entry>
              <entry>Return current file size (RBF - LI, LII)</entry>
            </row>
            <row>
              <entry>SS.Pos</entry>
              <entry>$5</entry>
              <entry>Get current file position. (RBF - LI, LII)</entry>
            </row>
            <row>
              <entry>SS.EOF</entry>
              <entry>$6</entry>
              <entry>Test for end of file. (RBF, Acia - LI, LII)</entry>
            </row>
            <row>
              <entry>SS.DevNm</entry>
              <entry>$E</entry>
              <entry>Return device name. (IOMAN - LI, LII)</entry>
            </row>
            <row>
              <entry>SS.FD</entry>
              <entry>$F</entry>
              <entry>Read file descriptor sector. (RBF - LII)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
CODES 10-127 Reserved for future use.
</para>
      <para>
CODES 128-255 These getstat codes and their parameter passing
conventions are user definable (see the sections of this manual on
writing device drivers). The function code and register stack are passed
to the device driver.
</para>
      <para>
Parameter Passing Conventions
</para>
      <para>
The parameter passing conventions for each of these function codes are
given below:
</para>
      <bridgehead renderas="sect4">
SS.OPT (code $0): Read option section of the path descriptor.
</bridgehead>
      <para>
This call is handled mostly by IOMAN and should work with all File
Managers.
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist>
<member>(A) = Path number</member>
<member>(B) = Function code 0.</member>
<member>(X) = Address of place to put a 32 byte status packet.</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>Status packet.</entry>
            </row>
            <row>
              <entry>ERROR OUTPUT:</entry>
              <entry>
                <simplelist>
                  <member>(CC) = C bit set.</member>
                  <member>(B) = Appropriate error code.</member>
                </simplelist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: This getstat function reads the option section of the path
descriptor and copies it into the 32 byte area pointed to by the X
register. It is typically used to determine the current settings for
echo, auto line feed, etc. For a complete description of the status
packet, please see the section of this manual on path descriptors.
</para>
      <bridgehead renderas="sect4">
SS.Ready (code $1): Test for data available on SCF supported devices.
</bridgehead>
      <para>
RBF devices always return Ready.
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number.</member>
<member>(B) = Function code 1</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entrytbl cols="4">
    <colspec colwidth="0.5in" align="left" colsep="0" rowsep="0"/>
    <colspec colwidth="1in" align="center"/>
    <colspec colwidth="1in" align="center"/>
    <colspec colwidth="1in" align="center"/>
    <thead>
      <row>
        <entry/>
        <entry>Ready</entry>
        <entry>Not Ready</entry>
        <entry>Error</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>(CC)</entry>
        <entry>C bit clear</entry>
        <entry>C bit set</entry>
        <entry>C bit set</entry>
      </row>
      <row>
        <entry>(B)</entry>
        <entry>Zero</entry>
        <entry>$F6 (E$NRDY)</entry>
        <entry>Error code</entry>
      </row>
    </tbody>
              </entrytbl>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <bridgehead renderas="sect4">
SS.Size (code $2): Get current file Size (RBF supported devices only)
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
              <simplelist>
                <member>(A) = Path number.</member>
                <member>(B) = Function code 2</member>
              </simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>
              <simplelist>
                <member>(X) = M.S. 16 bits of current file size.</member>
                <member>(U) = L.S. 16 bits of current file size.</member>
              </simplelist>
              </entry>
            </row>
            <row>
              <entry>ERROR OUTPUT:</entry>
              <entry>
                <simplelist>
                  <member>(CC) = C bit set.</member>
                  <member>(B) = Appropriate error code.</member>
                </simplelist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <bridgehead renderas="sect4">
SS.POS (code $5): Get current file position (RBF supported devices only).
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
              <simplelist>
                <member>(A) = Path number</member>
                <member>(B) = Function code 5</member>
              </simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>
              <simplelist>
                <member>(X) = M.S. 16 bits of current file position.</member>
                <member>(U) = L.S. 16 bits of current file position.</member>
              </simplelist>
              </entry>
            </row>
            <row>
              <entry>ERROR OUTPUT:</entry>
              <entry>
                <simplelist>
                  <member>(CC) = C bit set.</member>
                  <member>(B) = Appropriate error code.</member>
                </simplelist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <bridgehead renderas="sect4">
SS.EOF (code $6): Test for end of file.
</bridgehead>
      <para>
SCF never returns EOF
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number.</member>
<member>(B) = Function code 6</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entrytbl cols="4">
    <colspec colwidth="0.5in" align="left" colsep="0" rowsep="0"/>
    <colspec colwidth="1in" align="center"/>
    <colspec colwidth="1in" align="center"/>
    <colspec colwidth="1in" align="center"/>
    <thead>
      <row>
        <entry/>
        <entry>Not EOF</entry>
        <entry>EOF</entry>
        <entry>Error</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>(CC)</entry>
        <entry>C bit clear</entry>
        <entry>C bit set</entry>
        <entry>C bit set</entry>
      </row>
      <row>
        <entry>(B)</entry>
        <entry>Zero</entry>
        <entry>$D3 (E$EOF)</entry>
        <entry>Error code</entry>
      </row>
    </tbody>
              </entrytbl>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <bridgehead renderas="sect4">
SS.DevNm (code $E) Return device name
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code $E</member>
<member>(X) = Address of 32 byte area for device name</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>Device name in 32 byte storage area</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <bridgehead renderas="sect4">
SS.FD (code $F) Read FD sector
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code $F</member>
<member>(X) = Address of 256 byte area for FD.</member>
<member>(Y) = Number of bytes to read (&lt;=256).</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>File descriptor placed in reserved area.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>
    <sect2 xml:id="i.makdir" xreflabel="I$MakDir">
      <title>I$MakDir - Make a new directory</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$MAKDIR</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 85</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <para>
              <simplelist><member>(B) = Directory attributes.</member>
<member>(X) = Address of pathlist.</member></simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(X) = Updated past pathlist (trailing spaces skipped).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bpnam"/>, <xref linkend="e.cef"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: MAKDIR is the only way a new directory file can be created. It
will create and initialize a new directory as specified by the pathlist.
The new directoryA file contains no entries, except for an entry for
itself (".") and its parent directory (".."). MAKDIR will fail on non-multifile devices.
</para>
      <para>
The caller is made the owner of the directory. MAKDIR does not return a
path number because directory files are not <quote>opened</quote> by this request (use
OPEN to do so). The new directory will automatically have its <quote>directory</quote>
bit set in the access permission attributes. The remaining attributes
are specified by the byte passed in the B register, which has individual
bits defined as follows:
</para>
      <para>
        <literallayout>
bit 0 = read permit
bit 1 = write permit
bit 2 = execute permit
bit 3 = public read permit
bit 4 = public write permit
bit 5 = public execute permit
bit 6 = nonsharable directory
bit 7 = (don't care)
</literallayout>
      </para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PthDBT</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>
      <simplelist>
        <member>LI - 
        <simplelist type="inline"><member>F$All64</member><member>F$PrsNam*</member><member>I$Attach</member><member>F$Ret64*</member><member>F$IOQu*</member><member>F$Send*</member><member>F$Find64*</member><member>FileMgr.</member><member>I$Detach*</member></simplelist>
    </member>
        <member>LII -
        <simplelist type="inline"><member>F$All64</member><member>F$LDABX*</member><member>F$PrsNam*</member><member>I$Attach</member><member>F$Ret64*</member><member>F$IOQu*</member><member>F$Send*</member><member>F$GProcP*</member><member>FileMgr.</member><member>I$Detach*</member></simplelist>
    </member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.open" xreflabel="I$Open">
      <title>I$Open - Open a path to a file or device</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$OPEN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 84</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Access mode (D S PE PW PR E W R)</member>
<member>(X) = Address of pathlist.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(X) = Updated past pathlist (trailing spaces skipped).</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.pthful"/>, <xref linkend="e.bpnam"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: Opens a path to an existing file or device as specified by the
pathlist. A path number is returned which is used in subsequent service
requests to identify the path.
</para>
      <para>
The access mode parameter specifies which subsequent read and/or write
operations are permitted as follows:
</para>
      <para>
        <literallayout>
        1 = read mode
        2 = write mode
        3 = update mode (both read and write)
</literallayout>
      </para>
      <para>
For RBF devices, Read mode should be used if preference to Update if the file
is not going to be modified. This will inhibit record locking, and could
dramatically improve system performance if more than one user is
accessing the file. The access mode must conform to the access
permission attributes associated with the file or device (see <xref linkend="i.create"/>).
Only the owner may access a file unless the appropriate <quote>public permit</quote>
bits are set.
</para>
      <para>
Files can be opened by several processes (users) simultaneously. Devices
have an attribute that specifies whether or not they are sharable on an
individual basis.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>

      <simplelist>
        <member>LI and LII -
          <simplelist type="inline">
            <member>D.Proc</member>
            <member>D.PthDBT</member>
          </simplelist>
        </member>
        <member>LII -
          <simplelist type="inline">
            <member>D.SysPrc</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI -
        <simplelist type="inline"><member>F$All64</member><member>F$PrsNam</member><member>I$Attach</member><member>F$Ret64*</member><member>F$IOQu*</member><member>F$Send*</member><member>F$Find64</member></simplelist>
    </member>
        <member>LII -
        <simplelist type="inline"><member>F$All64</member><member>F$LDAEX*</member><member>F$PrsNam</member><member>I$Attach</member><member>F$Ret64*</member><member>F$IOQu</member><member>F$Send*</member><member>F$GProcP</member></simplelist>
    </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
If the execution bit is set in the access mode, OS-9 will begin searching
for the file in the working execution directory (unless the pathlist
begins with a slash).
</para>
      <para>
LI - The nonsharable bit (bit 6) in the access mode can not lock other
users out of a file in OS-9 Level I. It is present only for upward
compatibility with OS-9 Level II.
</para>
      <para>
LII - If the non-sharable bit is set, the file will be opened for non-
sharable access regardless if the file is sharable.
</para>
      <para>
Directory files may be opened for read or write if the <literal>D</literal> bit (bit 7) is
set in the access mode.
</para>
      <para>
Open will always use the lowest path number available for the process
during the open.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.read" xreflabel="I$Read">
      <title>I$Read - Read data from a file or device</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$READ</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 89</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(X) = Address to store data.</member>
<member>(Y) = Maximum number of bytes to read.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(Y) Number of bytes actually read.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.read"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: Reads a specified number of bytes from the path number given.
The path must previously have been opened in READ or UPDATE mode. The
data is returned exactly as read from the file/device without additional
processing or editing such as backspace, line delete, end-of-file, etc.
If there is not enough data in the file to satisfy the read request,
fewer bytes will be read than requested, but an end of file error is not
returned.
</para>
      <para>
After all data in a file has been read, the next I$READ service request
will return and end of file error.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
        <member>D.PthDBT</member>
    </simplelist>
</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI and LII - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>F$IOQu*</member>
                <member>FileMgr</member>
                <member>F$Send*</member>
            </simplelist>
        </member>
        <member>LII -
            <simplelist type="inline">
                <member>F$GProcP</member>
            </simplelist>
        </member>
    </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
The keyboard X-ON, X-OFF characters may be filtered out of the
input data on SCF-type devices unless the corresponding entries in the
path descriptor have been set to zero. It may be desirable to modify the
device descriptor so that these values in the path descriptor are
initialized to zero when the path is opened.
</para>
      <para>
For LII RBF devices, if the file is open for Update, the record read will
be locked out. See the Record Locking section.
</para>
      <para>
The number of bytes requested will be read unless:
</para>
      <orderedlist numeration="upperalpha">
        <listitem>
          <para>An end-of-file occurs</para>
        </listitem>
        <listitem>
          <para>An end-of-record occurs (SCF only)</para>
        </listitem>
        <listitem>
          <para>An error condition occurs.</para>
        </listitem>
      </orderedlist>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.readln" xreflabel="I$ReadLn">
      <title>I$ReadLn - Read a text line with editing</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$READLN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 8B</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(X) = Address to store data.</member>
<member>(Y) = Maximum number of bytes to read.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(Y) Actual number of bytes read.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.read"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: READLN is similar to <quote>READ</quote> except it reads data from the
input file or device until a carriage return character is encountered.
Also, ReadLn causes line editing to occur on SCF-type devices. Line
editing refers to backspace, line delete, echo, automatic line feed, etc.
</para>
      <para>
SCF requires that the last byte entered be an end-of-record character
(normally carriage return). If more data is entered than the maximum
specified, it will not be accepted and a PD.OVF character (normally bell)
will be echoed. For example, a ReadLn of exactly one byte will accept
only a carriage return to return without error.
</para>
      <para>
After all data in a file has been read, the next I$ReadLn service request
will return an end of file error.
</para>
      <para>
NOTE: For more information on line editing, see 7.1.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
        <member>D.PthDBT</member>
    </simplelist>
</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI and LII - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>I$IOQu*</member>
                <member>FileMgr</member>
                <member>F$Send*</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
                <member>F$GProcP*</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.seek" xreflabel="I$Seek">
      <title>I$Seek - Reposition the logical file pointer</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$SEEK</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 88</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(X) = M.S. 16 bits of desired file position.</member>
<member>(U) = L.S. 16 bits of desired file position.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bpnum"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: SEEK repositions the path's <quote>file pointer</quote>; which is the 32-
bit address of the the next byte in the file to be read or written.
</para>
      <para>
A seek may be performed to any value even if the file is not large
enough. Subsequent WRITEs will automatically expand the file to the
required size (if possible), but READS will return an end-of-file
condition. Note that a SEEK to address zero is the same as a <quote>rewind</quote>
operation.
</para>
      <para>
Seeks to non-random access devices are usually ignored and return without error.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
        <member>D.PthDBT</member>
    </simplelist>
</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>

      <simplelist>
        <member>LI and LII - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>File Mgr</member>
                <member>F$IOQu*</member>
                <member>F$Send*</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
                <member>F$GProcP*</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>CAVEATS:</term>
      <listitem>
      <para>
On RBF devices, seeking to a new disk sector causes the
internal disk buffer to be rewritten to disk if it has been modified.
Seek does not change the state of record locking.
</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>
    <sect2 xml:id="i.setstt" xreflabel="I$SetStt">
      <title>I$SetStt - Set file/device status</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$SETSTT</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F BE</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(B) = Function code.</member>
<member>(Other registers depend upon the function code).</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(Depends upon the function code).</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
            <para>LI and LII - <xref linkend="e.bpnum"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system call is a <quote>wild card</quote> call used to handle individual device parameters that:
</para>
      <orderedlist numeration="loweralpha">
        <listitem>
          <para>are not uniform on all devices</para>
        </listitem>
        <listitem>
          <para>are highly hardware dependent</para>
        </listitem>
        <listitem>
          <para>need to be user-changeable</para>
        </listitem>
      </orderedlist>
      <para>
The exact operation of this call depends on the device driver and file
manager associated with the path. A typical use is to set a terminal's
parameters for backspace character, delete character, echo on/off, null
padding, paging etc. It is commonly used in conjunction with the GETSTT
service request which is used to read the device's operating parameters
etc. Below are the presently defined function codes:
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="3">
          <colspec colwidth="1.2in"/>
          <colspec colwidth="1in"/>
          <colspec colwidth="3.5in"/>
          <thead>
            <row rowsep="1">
              <entry>MNEMONIC</entry>
              <entry>CODE</entry>
              <entry>FUNCTION</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>SS.OPT</entry>
              <entry>$0</entry>
              <entry>Write the 32 byte option section of the path descriptor (SCF,RBF - LI,LII)</entry>
            </row>
            <row>
              <entry>SS.Size</entry>
              <entry>$2</entry>
              <entry>Set the file size (RBF - LI,LII)</entry>
            </row>
            <row>
              <entry>SS.Reset</entry>
              <entry>$3</entry>
              <entry>Restore head to track zero*</entry>
            </row>
            <row>
              <entry>SS.WTrk</entry>
              <entry>$4</entry>
              <entry>Write (format) track*</entry>
            </row>
            <row>
              <entry>SS.Feed</entry>
              <entry>$9</entry>
              <entry>Issue Form Feed (SCF)</entry>
            </row>
            <row>
              <entry>SS.FRZ</entry>
              <entry>$A</entry>
              <entry>Freeze DD. information*</entry>
            </row>
            <row>
              <entry>SS.SPT</entry>
              <entry>$B</entry>
              <entry>Set Sectors per track*</entry>
            </row>
            <row>
              <entry>SS.SQD</entry>
              <entry>$C</entry>
              <entry>Sequence down disk drive*</entry>
            </row>
            <row>
              <entry>SS.DCmd</entry>
              <entry>$D</entry>
              <entry>Direct command to hard disk controller*</entry>
            </row>
            <row>
              <entry>SS.FD</entry>
              <entry>$F</entry>
              <entry>Write FD sector (RBF - LII)</entry>
            </row>
            <row>
              <entry>SS.Ticks</entry>
              <entry>$10</entry>
              <entry>Set Lockout honor duration (RBF - LII)</entry>
            </row>
            <row>
              <entry>SS.Lock</entry>
              <entry>$11</entry>
              <entry>Lock/Release record (RBF - LII)</entry>
            </row>
            <row>
              <entry>SS.SSIG</entry>
              <entry>$1A</entry>
              <entry>Send signal on data ready (ACIA - LII)</entry>
            </row>
            <row>
              <entry>SS.Relea</entry>
              <entry>$1B</entry>
              <entry>Release device (ACIA - LII)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
* These setstats exist in Microware supplied disk drivers (if needed).
Only SS.Reset and SS.WTrk are required; the others are implemented to
allow reading nonstandard disks. Microware has not supplied any software
which makes use of them.
</para>
      <para>
Codes 128 through 255 and their parameter passing conventions are user
definable (see the sections of this manual on writing device drivers).
The function code and register stack are passed to the device driver.
</para>
      <bridgehead renderas="sect4">
SS.OPT (code 0): Write option section of path descriptor.
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code 0</member>
<member>(X) = Address of a 32 byte status packet</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: This setstat function writes the option section of the path
descriptor from the 32 byte status packet pointed to by the X register.
It is typically used to set the device operating parameters, such as
echo, auto line feed, etc. This call is handled by the File Managers,
only copies values that are appropriate to be changed by user programs.
</para>
      <bridgehead renderas="sect4">
SS.SIZE (code 2): Set file size (RBF-type devices)
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code 2</member>
<member>(X) = M.S. 16 bits of desired file size.</member>
<member>(U) = L.S. 16 bits of desired file size.</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: This setstat function is used to change the file's size.
</para>
      <bridgehead renderas="sect4">
SS.RESET (code 3): Restore head to track zero.
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code 3</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Home disk head to track zero. Used for formatting and for error recovery.
</para>
      <bridgehead renderas="sect4">
SS.WTRK (code 4): Write track.
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code 4</member>
<member>(X) = Address of track buffer.</member>
<member>(U) = Track number</member>
<member>(Y) - Side/density<literallayout>
For Floppy: Y = side/density
For Hard Disk Y = side only (may be more than one)

        Bit B0 = SIDE (0 = side zero, 1 = side one)
        Bit B1 = DENSITY (0 = single, 1 = double)</literallayout></member>
        </simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: This code causes a format track (most floppy disks) operation
to occur. For hard disks or floppy disks with a <quote>format entire disk</quote>
command, this command should format the entire media only when the track
number equals zero.
</para>
      <bridgehead renderas="sect4">
SS.FRZ (code $A): Freeze DD. Information
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = SS.FRZ function code</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Inhibits the reading of identification sector (LSN 0) to memory
DD.xxx variables (that define disk formats) so non-standard disks may be
read.
</para>
      <bridgehead renderas="sect4">
SS.SPT (Code $B): Set Sectors Per Track
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = SS.SPT function code</member>
<member>(X) = new sectors per track</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Sets a different number of sectors per track so non-standard
disks may be read.
</para>
      <bridgehead renderas="sect4">
SS.SQD (Code $C): Sequence Down Disk
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = path number</member>
<member>(B) = SS.SQD function code</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Initiates power-down sequence for Winchester or other hard
disks which have sequence-down requirements prior to removal of power.
</para>
      <bridgehead renderas="sect4">
SS.DCmd (Code $D): Direct Command to Disk Controller
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>Varies</entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>Varies</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Transmits a command directly to an intelligent disk controller
for special functions. Parameters and commands are hardware dependent
for specific systems.
</para>
      <bridgehead renderas="sect4">
SS.FD (Code $F): Write FD sector
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = Path number</member>
<member>(B) = Function code</member>
<member>(X) = Address of FD sector image</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Change FD sector
</para>
      <para>
NOTE: Only FD.OWN, FD.DAT, and FD.Creat can be changed. These are the
only fields written back to disk. If at least 16 bytes are not read
using the GETSTT call, garbage could be written out to the FD sector.
</para>
      <bridgehead renderas="sect4">
SS.Lock (Code $10): Lock out a section of a file.
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = path number</member>
<member>(B) = SS.Lock code</member>
<member>(X) = M.S. of lockout size</member>
<member>(U) = L.S. of lockout size</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: SS.Lock locks out a section of the file from the current
position up to the number of bytes requested. If 0 bytes are requested,
all locks (Record Lock, EOF Lock, and File Lock) are removed. If (X) and
(U) contain $FFFF FFFF, then the entire file is locked out regardless of
where the file pointer is. This is a special type of file lock that
remains in effect until released by SS.Lock(0), a read or write of zero
bytes, or the file is closed. There is no way to gain file lock using
only Read or Write system calls.
</para>
      <bridgehead renderas="sect4">
SS.Ticks (Code $11) Wait specified number of ticks for record release.
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = path number</member>
<member>(B) = SS.Ticks code</member>
<member>(X) = Delay interval</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: Normally, if a read or write request is issued for part of a
file that is locked out by another user, RBF sleeps indefinately until
the conflict is removed. The SS.Ticks call may be used to cause an error
(#252) to be returned to the user program if the conflict still exists
after the specified number of ticks of the system clock have elapsed.
</para>
      <para>
The delay interval is used directly as a parameter to RBF's conflict
sleep request. The value zero (RBF's default) causes a sleep forever
until the record is released. A delay value of one effectively means
that if the lock is not released immediately, an error is returned.
</para>
      <bridgehead renderas="sect4">
SS.SSIG (Code $1A) Send Signal on data ready
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = path number</member>
<member>(B) = function code</member>
<member>(X) = user defined signal code</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: SS.SSIG sets up a signal to be sent to a process when a device
has data ready. SS.SSIG must be reset each time the signal is sent if it
is to be used again. The device is considered busy, and will return an
error if any read request arrives before the signal is sent. Write
requests are allowed to the device while in this state.
</para>
      <bridgehead renderas="sect4">
SS.Relea (Code $1B) Release device
</bridgehead>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.4in"/>
          <colspec colwidth="3.6in"/>
          <tbody>
            <row>
              <entry>INPUT:</entry>
              <entry>
                <simplelist><member>(A) = path number</member>
<member>(B) = function code</member></simplelist>
              </entry>
            </row>
            <row>
              <entry>OUTPUT:</entry>
              <entry>None</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
FUNCTION: SS.Relea clears the the signal to be sent from a device so it
will no longer send a signal on data ready.
</para>
    </sect2>
    <sect2 xml:id="i.write" xreflabel="I$Write">
      <title>I$Write - Write data to a file or device</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$WRITE</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 8A</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
              <simplelist><member>(A) = Path number.</member>
<member>(X) = Address of data to write.</member>
<member>(Y) = Number of bytes to write.</member></simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(Y) Number of bytes actually written.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.bmode"/></member>
                        <member><xref linkend="e.write"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: WRITE outputs one or more bytes to a file or device associated
with the path number specified. The path must have been OPENed or
CREATEd in the WRITE or UPDATE access modes.
</para>
      <para>
Data is written to the file or device without processing or editing. If
data is written past the present end-of-file, the file is automatically
expanded.
</para>
  <variablelist role="factsheet">
    <varlistentry>
      <term>DATA:</term>
      <listitem>
      <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
        <member>D.PthDBT</member>
    </simplelist>
</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>SYSTEM CALLS:</term>
      <listitem>
      <simplelist>
        <member>LI - 
            <simplelist type="inline">
                <member>F$Find64</member>
                <member>F$IOQu*</member>
                <member>File Mgr</member>
                <member>F$Send*</member>
          </simplelist>
        </member>
        <member>LII - 
          <simplelist type="inline">
                <member>F$GProcP*</member>
            </simplelist>
        </member>
      </simplelist>
      </listitem>
    </varlistentry>
  </variablelist>

    </sect2>
    <sect2 xml:id="i.writln" xreflabel="I$WritLn">
      <title>I$WritLn - Write a line of text with editing</title>
      <variablelist role="factsheet">
        <varlistentry>
          <term>ASSEMBLER CALL:</term>
          <listitem>
            <para>OS9 I$WRITLN</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>MACHINE CODE:</term>
          <listitem>
            <para>103F 8C</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ROUTINE LOCATION:</term>
          <listitem>
            <para>LI and LII - I/O</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>INPUT:</term>
          <listitem>
            <simplelist>
              <member>(A) = Path number.</member>
<member>(X) = Address of data to write.</member>
<member>(Y) = Maximum number of bytes to write.</member>
            </simplelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>OUTPUT:</term>
          <listitem>
            <para>(Y) = Actual number of bytes written.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ERROR OUTPUT:</term>
          <listitem>
            <para>
              <simplelist>
                <member>(CC) = C bit set.</member>
                <member>(B) = Appropriate error code.</member>
              </simplelist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>POSSIBLE ERRORS:</term>
          <listitem>
              <simplelist>
                <member>LI and LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.bpnum"/></member>
                        <member><xref linkend="e.bmode"/></member>
                    </simplelist>
                </member>
                <member>LII -
                    <simplelist type="inline">
                        <member><xref linkend="e.write"/></member>
                    </simplelist>
                </member>
              </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
FUNCTION: This system call is similar to WRITE except it writes data
until a carriage return character is encountered. Line editing is also
activated for character-oriented devices such as terminals, printers,
etc. The line editing refers to auto line feed, null padding at end-of-
line, etc.
</para>
      <para>
For more information about line editing, see section 7.1.
</para>
      <variablelist role="factsheet">
        <varlistentry>
          <term>DATA:</term>
          <listitem>
          <para>
LI and LII - <simplelist type="inline">
        <member>D.Proc</member>
        <member>D.PthDBT</member>
    </simplelist>
    </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SYSTEM CALLS:</term>
          <listitem>
            <simplelist>
              <member>LI and LII - <simplelist type="inline"><member>F$Find64</member><member>F$IOQu*</member><member>File Mgr</member><member>F$Send*</member></simplelist>
</member>
              <member>LII - F$GProcP</member>
            </simplelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>
</chapter>
